# Bug Fixes Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 11 confirmed bugs across composables and server routes found by bug-finder scan.

**Architecture:** Targeted surgical edits only — no refactoring. Each task modifies 1-2 files.

**Tech Stack:** Vue 3, Nuxt 3, TypeScript, Pinia, Supabase, Nitro

**Corrections from bug report (false positives NOT to fix):**
- CSRF bypass in smartDelete — already uses `$fetchAuth` in all three composables ✅
- useCoaches reactivity — uses `ref()` not `shallowRef()`, mutations work correctly ✅
- useNotifications reactivity — uses `ref()`, mutations work correctly ✅
- useAuth busy-wait — `finally` block always resets `initializationAttempt`, can't spin forever ✅
- useSessionTimeout rememberMe guard — intentional design (non-rememberMe relies on Supabase TTL)

---

### Task 1: Fix useInteractions shallowRef mutation in createInteraction

**Files:**
- Modify: `composables/useInteractions.ts:344`

**Step 1: Edit the file**

```typescript
// OLD (line 344):
interactions.value.unshift(data);

// NEW:
interactions.value = [data, ...interactions.value];
```

**Step 2: Verify type-check passes**
```bash
cd /Volumes/AlphabetSoup/TheRecruitingCompass/code/recruiting-compass-web
npm run type-check 2>&1 | head -30
```

**Step 3: Run tests**
```bash
npm run test -- --reporter=dot 2>&1 | tail -20
```

**Step 4: Commit**
```bash
git add composables/useInteractions.ts
git commit -m "fix: replace shallowRef unshift with reference-replacing spread in createInteraction"
```

---

### Task 2: Fix orphaned uploads in useInteractions.createInteraction

**Files:**
- Modify: `composables/useInteractions.ts:321-333`

**Problem:** If the attachment path update fails after uploading files, storage files are orphaned. The error is only logged, not thrown.

**Step 1: Edit the attachment error handling block**

Find this block (~line 321):
```typescript
if (files && files.length > 0) {
  const uploadedPaths = await uploadAttachments(files, data.id);
  if (uploadedPaths.length > 0) {
    const { error: updateError } =
      await // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (supabase.from("interactions") as any)
        .update({ attachments: uploadedPaths })
        .eq("id", data.id);
    if (updateError)
      logger.error("Failed to update attachment paths:", updateError);
  }
}
```

Replace with:
```typescript
if (files && files.length > 0) {
  const uploadedPaths = await uploadAttachments(files, data.id);
  if (uploadedPaths.length > 0) {
    const { error: updateError } =
      await // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (supabase.from("interactions") as any)
        .update({ attachments: uploadedPaths })
        .eq("id", data.id);
    if (updateError) {
      logger.error("Failed to update attachment paths:", updateError);
      throw new Error("Failed to save attachments. Interaction created but files were not linked.");
    }
  }
}
```

**Step 2: Run tests**
```bash
npm run test -- --reporter=dot 2>&1 | tail -20
```

**Step 3: Commit**
```bash
git add composables/useInteractions.ts
git commit -m "fix: throw error on attachment path update failure to prevent orphaned uploads"
```

---

### Task 3: Fix missing loading state in useRecommendationLetters.deleteLetter

**Files:**
- Modify: `composables/useRecommendationLetters.ts:97-116`

**Step 1: Edit the file**

Add `loading.value = true` at the start of `deleteLetter`:

```typescript
// OLD (line 97-99):
const deleteLetter = async (id: string) => {
  error.value = null;

// NEW:
const deleteLetter = async (id: string) => {
  loading.value = true;
  error.value = null;
```

**Step 2: Commit**
```bash
git add composables/useRecommendationLetters.ts
git commit -m "fix: set loading state at start of deleteLetter to prevent double-click"
```

---

### Task 4: Fix expired session not triggering logout in useSessionTimeout

**Files:**
- Modify: `composables/useSessionTimeout.ts:129-131`

**Problem:** When `timeUntilTimeout <= 0` is detected during `checkTimeout()`, the code only removes the localStorage key and returns. It never calls `handleTimeout()`, so the user is not actually logged out.

**Step 1: Edit the expired session block**

Find this block (~line 129):
```typescript
// Session expired
if (timeUntilTimeout <= 0) {
  localStorage.removeItem("session_preferences");
  return;
}
```

Replace with:
```typescript
// Session expired — log the user out
if (timeUntilTimeout <= 0) {
  handleTimeout();
  return;
}
```

Note: `handleTimeout()` already removes `session_preferences` internally, so removing it here avoids double-removal.

**Step 2: Verify type-check**
```bash
npm run type-check 2>&1 | head -20
```

**Step 3: Commit**
```bash
git add composables/useSessionTimeout.ts
git commit -m "fix: call handleTimeout() when expired session detected to actually log user out"
```

---

### Task 5: Fix Math.random() for family code generation in useAuth

**Files:**
- Modify: `composables/useAuth.ts:55-62`

**Problem:** `generateFamilyCode()` uses `Math.random()` which is not cryptographically secure. Family codes serve as shared secrets granting parent access to student data.

**Step 1: Replace the function**

Old:
```typescript
function generateFamilyCode(): string {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let code = "";
  for (let i = 0; i < 8; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return `FAM-${code}`;
}
```

New:
```typescript
function generateFamilyCode(): string {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const randomValues = new Uint8Array(8);
  crypto.getRandomValues(randomValues);
  const code = Array.from(randomValues)
    .map((v) => chars[v % chars.length])
    .join("");
  return `FAM-${code}`;
}
```

**Step 2: Verify type-check**
```bash
npm run type-check 2>&1 | head -20
```

**Step 3: Commit**
```bash
git add composables/useAuth.ts
git commit -m "fix: use crypto.getRandomValues() for cryptographically secure family code generation"
```

---

### Task 6: Fix false success in bulk-delete-users when auth deletion fails

**Files:**
- Modify: `server/api/admin/bulk-delete-users.post.ts:183-217`

**Problem:** When `supabaseAdmin.auth.admin.deleteUser()` returns an error (non-throwing), the code falls through and still pushes to `deletedEmails` and logs success.

**Step 1: Edit the auth deletion block**

Find (~line 183):
```typescript
await Promise.all(
  resolvedUsers.map(async ({ email: targetEmail, id: targetUserId }) => {
    try {
      if (supabaseAdmin.auth.admin?.deleteUser) {
        const { error: deleteError } =
          await supabaseAdmin.auth.admin.deleteUser(targetUserId);

        if (deleteError) {
          logger.warn(
            `Failed to delete auth user ${targetUserId} (${targetEmail}):`,
            deleteError,
          );
        }
      }

      deletedEmails.push(targetEmail);
      logger.info(
        `User ${targetEmail} (${targetUserId}) and all associated data deleted by admin ${user.id}`,
      );
    } catch (authError) {
```

Replace the inner block with:
```typescript
await Promise.all(
  resolvedUsers.map(async ({ email: targetEmail, id: targetUserId }) => {
    try {
      if (supabaseAdmin.auth.admin?.deleteUser) {
        const { error: deleteError } =
          await supabaseAdmin.auth.admin.deleteUser(targetUserId);

        if (deleteError) {
          logger.warn(
            `Failed to delete auth user ${targetUserId} (${targetEmail}):`,
            deleteError,
          );
          errors.push({ email: targetEmail, reason: deleteError.message || "Auth deletion failed" });
          return;
        }
      }

      deletedEmails.push(targetEmail);
      logger.info(
        `User ${targetEmail} (${targetUserId}) and all associated data deleted by admin ${user.id}`,
      );
    } catch (authError) {
```

**Step 2: Verify type-check**
```bash
npm run type-check 2>&1 | head -20
```

**Step 3: Commit**
```bash
git add server/api/admin/bulk-delete-users.post.ts
git commit -m "fix: report auth deletion failure as error instead of false success in bulk-delete-users"
```

---

### Task 7: Fix cascade-delete silently ignoring child delete errors

**Files:**
- Modify: `server/api/schools/[id]/cascade-delete.post.ts:75-93`
- Modify: `server/api/coaches/[id]/cascade-delete.post.ts:76-93`

**Problem (schools):** The `Promise.all` destructures only `count` from each child delete operation — `error` is discarded. If any child delete fails, the parent school is still deleted, breaking referential integrity.

**Step 1: Fix schools cascade-delete**

Find (~line 75):
```typescript
const [
  { count: historyCount },
  { count: coachCount },
  { count: interactionCount },
  { count: offerCount },
  { count: postCount },
  { count: docCount },
  { count: eventCount },
  { count: suggestionCount },
] = await Promise.all([
  client.from("school_status_history").delete().eq("school_id", schoolId),
  client.from("coaches").delete().eq("school_id", schoolId),
  client.from("interactions").delete().eq("school_id", schoolId),
  client.from("offers").delete().eq("school_id", schoolId),
  client.from("social_media_posts").delete().eq("school_id", schoolId),
  client.from("documents").delete().eq("school_id", schoolId),
  client.from("events").delete().eq("school_id", schoolId),
  client.from("suggestion").delete().eq("related_school_id", schoolId),
]);
```

Replace with:
```typescript
const [
  { count: historyCount, error: historyError },
  { count: coachCount, error: coachError },
  { count: interactionCount, error: interactionError },
  { count: offerCount, error: offerError },
  { count: postCount, error: postError },
  { count: docCount, error: docError },
  { count: eventCount, error: eventError },
  { count: suggestionCount, error: suggestionError },
] = await Promise.all([
  client.from("school_status_history").delete().eq("school_id", schoolId),
  client.from("coaches").delete().eq("school_id", schoolId),
  client.from("interactions").delete().eq("school_id", schoolId),
  client.from("offers").delete().eq("school_id", schoolId),
  client.from("social_media_posts").delete().eq("school_id", schoolId),
  client.from("documents").delete().eq("school_id", schoolId),
  client.from("events").delete().eq("school_id", schoolId),
  client.from("suggestion").delete().eq("related_school_id", schoolId),
]);

const childErrors = [historyError, coachError, interactionError, offerError, postError, docError, eventError, suggestionError].filter(Boolean);
if (childErrors.length > 0) {
  logger.error("Child record deletion failed during cascade delete", { schoolId, errors: childErrors });
  throw createError({ statusCode: 500, statusMessage: "Failed to delete all related records" });
}
```

**Step 2: Fix coaches cascade-delete**

In `server/api/coaches/[id]/cascade-delete.post.ts`, the child deletes (lines 76-93) are sequential and don't check errors. Add error checking after each delete:

```typescript
// 1. Delete interactions
const { count: interactionCount, error: interactionError } = await client
  .from("interactions")
  .delete()
  .eq("coach_id", coachId);
if (interactionError) throw interactionError;
if (interactionCount) deleted.interactions = interactionCount;

// 2. Delete offers
const { count: offerCount, error: offerError } = await client
  .from("offers")
  .delete()
  .eq("coach_id", coachId);
if (offerError) throw offerError;
if (offerCount) deleted.offers = offerCount;

// 3. Delete social media posts
const { count: postCount, error: postError } = await client
  .from("social_media_posts")
  .delete()
  .eq("coach_id", coachId);
if (postError) throw postError;
if (postCount) deleted.social_media_posts = postCount;
```

**Step 3: Verify type-check**
```bash
npm run type-check 2>&1 | head -20
```

**Step 4: Commit**
```bash
git add server/api/schools/[id]/cascade-delete.post.ts server/api/coaches/[id]/cascade-delete.post.ts
git commit -m "fix: check child delete errors in cascade-delete to prevent orphaned child rows"
```

---

### Task 8: Fix roleCache memory leak in server/utils/auth.ts

**Files:**
- Modify: `server/utils/auth.ts:101-105`

**Problem:** Expired entries are detected on read but never removed from the Map. Over time in long-running processes, this grows unboundedly.

**Step 1: Delete expired entry on cache miss**

Find (~line 101):
```typescript
const cached = roleCache.get(userId);
if (cached && Date.now() < cached.expiresAt) {
  logger.info(`Role cache hit for user ${userId}`);
  return cached.role;
}
```

Replace with:
```typescript
const cached = roleCache.get(userId);
if (cached) {
  if (Date.now() < cached.expiresAt) {
    logger.info(`Role cache hit for user ${userId}`);
    return cached.role;
  }
  roleCache.delete(userId);
}
```

**Step 2: Commit**
```bash
git add server/utils/auth.ts
git commit -m "fix: evict expired roleCache entries on read to prevent memory leak"
```

---

### Task 9: Fix XSS in emailService.ts

**Files:**
- Modify: `server/utils/emailService.ts`

**Problem:** `title`, `message`, and `actionUrl` are interpolated directly into HTML without escaping. A database-stored value containing `<script>` or `javascript:` would execute in the email client.

**Step 1: Add an escape helper and apply it**

Add at the top of the file (after the imports):
```typescript
function escapeHtml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function sanitizeUrl(url: string): string {
  // Only allow http/https URLs — reject javascript: and data: schemes
  try {
    const parsed = new URL(url);
    if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
      return "#";
    }
    return url;
  } catch {
    // Relative URLs are allowed as-is
    return url.startsWith("/") ? url : "#";
  }
}
```

Then update the template to escape values:
```typescript
const actionButton = actionUrl
  ? `<a href="${sanitizeUrl(actionUrl)}" style="...">View Details</a>`
  : "";

const htmlContent = `
  ...
  <h1 ...>${escapeHtml(title)}</h1>
  ...
  <p ...>${escapeHtml(message)}</p>
  ...
`;
```

**Step 2: Verify type-check**
```bash
npm run type-check 2>&1 | head -20
```

**Step 3: Commit**
```bash
git add server/utils/emailService.ts
git commit -m "fix: escape HTML in email template to prevent XSS via title/message/actionUrl"
```

---

### Task 10: Fix N+1 duplicate queries in social/sync-all.post.ts

**Files:**
- Modify: `server/api/social/sync-all.post.ts:120-212`

**Problem:** For each Twitter/Instagram post, the code runs a separate Supabase query to check for an existing post by URL. With many users and posts, this results in hundreds/thousands of sequential queries per sync run.

**Step 1: Collect all post URLs upfront then batch-check for existing ones**

Replace the per-post duplicate check loops with a batched approach. Before the `// Fetch Twitter posts` block, collect all URLs, query existing ones in bulk, then use a Set for O(1) lookup:

```typescript
let postsInserted = 0;

// Gather all posts first
const twitterPosts = twitterHandles.length > 0
  ? await twitterService.fetchTweetsForHandles(twitterHandles)
  : [];
const instagramPosts = instagramHandles.length > 0
  ? await instagramService.fetchMediaForHandles(instagramHandles)
  : [];

stats.totalPostsFetched += twitterPosts.length + instagramPosts.length;

const allPosts = [...twitterPosts, ...instagramPosts];
if (allPosts.length === 0) {
  stats.totalPostsInserted += postsInserted;
  stats.successfulUsers++;
  continue; // next user
}

// Batch check for existing posts (1 query instead of N)
const allPostUrls = allPosts.map((p) => p.post_url);
const { data: existingPosts } = await supabase
  .from("social_media_posts")
  .select("post_url")
  .in("post_url", allPostUrls);

const existingUrlSet = new Set((existingPosts || []).map((p) => p.post_url));

// Process all posts using the Set for O(1) dedup
for (const post of allPosts) {
  if (!existingUrlSet.has(post.post_url)) {
    const school = schools?.find(
      (s) => s.twitter_handle === post.author_handle || s.instagram_handle === post.author_handle,
    );
    const coach = coaches?.find(
      (c) => c.twitter_handle === post.author_handle || c.instagram_handle === post.author_handle,
    );

    const sentimentResult = analyzeSentiment(post.post_content);

    const { error: insertError } = await supabase
      .from("social_media_posts")
      .insert({
        school_id: school?.id || null,
        coach_id: coach?.id || null,
        platform: post.platform,
        post_url: post.post_url,
        post_content: post.post_content,
        post_date: post.post_date,
        author_name: post.author_name,
        author_handle: post.author_handle,
        engagement_count: post.engagement_count,
        is_recruiting_related: post.is_recruiting_related,
        sentiment: sentimentResult.sentiment,
      });

    if (!insertError) {
      postsInserted++;
    }
  }
}
```

Remove the old separate Twitter and Instagram fetch+loop blocks.

**Step 2: Verify type-check**
```bash
npm run type-check 2>&1 | head -20
```

**Step 3: Commit**
```bash
git add server/api/social/sync-all.post.ts
git commit -m "fix: batch-check duplicate posts in one query instead of N+1 per-post queries"
```

---

## Execution Order

Tasks 1, 2, 3, 5 are independent composable edits — can be done in parallel.
Tasks 4 is session-related — do after reading existing tests.
Tasks 6, 7, 8, 9, 10 are server-side — independent, can parallelize.
