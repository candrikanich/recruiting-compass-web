# Architecture Round 5 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Address the three remaining architectural issues identified in Round 4: client-side structured logging, pages with direct Supabase calls, and request deduplication in key composables.

**Architecture:** Create a `utils/logger.ts` client logger mirroring the server-side `createLogger()` API, extract direct Supabase calls in `pages/recommendations/index.vue` and `pages/settings/social-sync.vue` into proper composables, and add in-flight deduplication to `useSchools` and `useCoaches`.

**Tech Stack:** Nuxt 3, Vue 3, TypeScript strict, Vitest, Pinia, Supabase

---

## Phase 1: Client-Side Structured Logger

### Task 1: Create the client logger utility with tests

**Files:**
- Create: `utils/logger.ts`
- Create: `tests/unit/utils/logger.spec.ts`

**Step 1: Write the failing tests**

```typescript
// tests/unit/utils/logger.spec.ts
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { createClientLogger } from "~/utils/logger";

describe("createClientLogger", () => {
  let consoleSpy: { log: any; warn: any; error: any };

  beforeEach(() => {
    consoleSpy = {
      log: vi.spyOn(console, "log").mockImplementation(() => {}),
      warn: vi.spyOn(console, "warn").mockImplementation(() => {}),
      error: vi.spyOn(console, "error").mockImplementation(() => {}),
    };
  });

  afterEach(() => {
    vi.restoreAllMocks();
    delete (import.meta as any).env.VITE_LOG_LEVEL;
  });

  it("returns an object with debug/info/warn/error methods", () => {
    const logger = createClientLogger("test");
    expect(typeof logger.debug).toBe("function");
    expect(typeof logger.info).toBe("function");
    expect(typeof logger.warn).toBe("function");
    expect(typeof logger.error).toBe("function");
  });

  it("includes context and level in log output", () => {
    const logger = createClientLogger("my-composable");
    logger.info("something happened");
    expect(consoleSpy.log).toHaveBeenCalledWith(
      expect.stringContaining("[my-composable]"),
      "something happened",
    );
  });

  it("logs data when provided", () => {
    const logger = createClientLogger("test");
    logger.error("fetch failed", { code: 42 });
    expect(consoleSpy.error).toHaveBeenCalledWith(
      expect.any(String),
      "fetch failed",
      expect.objectContaining({ code: 42 }),
    );
  });

  it("redacts sensitive fields from data", () => {
    const logger = createClientLogger("test");
    logger.info("user loaded", { id: "1", password: "secret", token: "abc" });
    const call = consoleSpy.log.mock.calls[0];
    const data = call[2];
    expect(data.password).toBe("[REDACTED]");
    expect(data.token).toBe("[REDACTED]");
    expect(data.id).toBe("1");
  });

  it("uses console.warn for warn level", () => {
    const logger = createClientLogger("test");
    logger.warn("low disk");
    expect(consoleSpy.warn).toHaveBeenCalled();
  });

  it("uses console.error for error level", () => {
    const logger = createClientLogger("test");
    logger.error("boom");
    expect(consoleSpy.error).toHaveBeenCalled();
  });

  it("extracts safe properties from Error objects", () => {
    const logger = createClientLogger("test");
    const err = new Error("oops");
    logger.error("caught", err);
    const call = consoleSpy.error.mock.calls[0];
    const data = call[2];
    expect(data).toEqual(expect.objectContaining({ message: "oops" }));
    expect(data.stack).toBeUndefined(); // no stack in production-like env
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- tests/unit/utils/logger.spec.ts
```
Expected: FAIL with "Cannot find module '~/utils/logger'"

**Step 3: Implement the client logger**

```typescript
// utils/logger.ts
/**
 * Client-side logging utility.
 * Mirrors the server-side createLogger() API so composables/stores can log
 * with the same level-filtering and sanitization discipline as API routes.
 *
 * Log level is controlled by the VITE_LOG_LEVEL env var (debug/info/warn/error).
 * Defaults to "warn" in production, "debug" in development.
 */

type LogLevel = "debug" | "info" | "warn" | "error";

interface Logger {
  debug: (message: string, data?: unknown) => void;
  info: (message: string, data?: unknown) => void;
  warn: (message: string, data?: unknown) => void;
  error: (message: string, error?: unknown) => void;
}

const LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

const SENSITIVE_FIELDS = new Set([
  "password",
  "password_hash",
  "token",
  "access_token",
  "refresh_token",
  "api_key",
  "secret",
  "credit_card",
  "ssn",
  "authorization",
  "cookie",
]);

function sanitizeData(data: unknown): unknown {
  if (data === null || data === undefined) return data;

  if (data instanceof Error) {
    return { name: data.name, message: data.message };
  }

  if (Array.isArray(data)) {
    return data.map(sanitizeData);
  }

  if (typeof data === "object") {
    const sanitized: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(
      data as Record<string, unknown>,
    )) {
      const lower = key.toLowerCase();
      if (SENSITIVE_FIELDS.has(lower) || lower.includes("password")) {
        sanitized[key] = "[REDACTED]";
      } else if (typeof value === "object" && value !== null) {
        sanitized[key] = sanitizeData(value);
      } else {
        sanitized[key] = value;
      }
    }
    return sanitized;
  }

  return data;
}

/**
 * Create a structured client-side logger.
 *
 * Usage in composables:
 * ```ts
 * import { createClientLogger } from "~/utils/logger";
 * const logger = createClientLogger("useSchools");
 * logger.info("fetchSchools called", { familyId });
 * logger.error("Fetch failed", err);
 * ```
 */
export function createClientLogger(context: string): Logger {
  const isDev = import.meta.env.DEV;
  const configuredLevel = (import.meta.env.VITE_LOG_LEVEL as LogLevel) ||
    (isDev ? "debug" : "warn");
  const minPriority = LOG_LEVEL_PRIORITY[configuredLevel] ?? 2;

  const log = (level: LogLevel, message: string, data?: unknown) => {
    if (LOG_LEVEL_PRIORITY[level] < minPriority) return;

    const timestamp = new Date().toISOString();
    const prefix = `[${timestamp}] [${context}] [${level.toUpperCase()}]`;
    const consoleMethod: "log" | "warn" | "error" =
      level === "warn" ? "warn" : level === "error" ? "error" : "log";

    if (data !== undefined) {
      console[consoleMethod](prefix, message, sanitizeData(data));
    } else {
      console[consoleMethod](prefix, message);
    }
  };

  return {
    debug: (msg, data?) => log("debug", msg, data),
    info: (msg, data?) => log("info", msg, data),
    warn: (msg, data?) => log("warn", msg, data),
    error: (msg, data?) => log("error", msg, data),
  };
}
```

**Step 4: Run tests to verify they pass**

```bash
npm test -- tests/unit/utils/logger.spec.ts
```
Expected: All tests PASS

**Step 5: Commit**

```bash
git add utils/logger.ts tests/unit/utils/logger.spec.ts
git commit -m "feat: add client-side structured logger utility"
```

---

### Task 2: Replace console statements in `stores/user.ts`

**Files:**
- Modify: `stores/user.ts`

**Step 1: Find all console usages**

```bash
grep -n "console\." stores/user.ts
```

**Step 2: Add logger import at top of stores/user.ts**

At the very top of the imports, add:
```typescript
import { createClientLogger } from "~/utils/logger";
```

After the imports but before `export const useUserStore`, add:
```typescript
const logger = createClientLogger("stores/user");
```

**Step 3: Replace each console statement**

Replace the pattern `console.debug(...)` → `logger.debug(...)`
Replace the pattern `console.warn(...)` → `logger.warn(...)`
Replace the pattern `console.error(...)` → `logger.error(...)`
Replace the pattern `console.log(...)` → `logger.info(...)`

All 18 statements follow this mapping exactly. No message text changes needed.

**Step 4: Run tests**

```bash
npm test -- tests/unit/stores
```
Expected: All store tests PASS

**Step 5: Commit**

```bash
git add stores/user.ts
git commit -m "refactor: replace console statements with structured logger in user store"
```

---

### Task 3: Replace console statements in key composables

**Files:**
- Modify: `composables/useSchools.ts`
- Modify: `composables/useCoaches.ts`
- Modify: `composables/useAuth.ts`
- Modify: `composables/useInteractions.ts`
- Modify: `composables/useActiveFamily.ts`
- Modify: `composables/useSchoolLogos.ts`
- Modify: `composables/useSavedSearches.ts`
- Modify: `composables/useViewLogging.ts`

**Step 1: For each composable, add logger import at top**

Pattern to apply to every file listed above:

```typescript
// Add to imports
import { createClientLogger } from "~/utils/logger";

// Add as module-level constant (BEFORE the export function, after imports)
const logger = createClientLogger("<composable-name>");
// e.g. createClientLogger("useSchools"), createClientLogger("useCoaches"), etc.
```

**Step 2: Replace console.* calls in each file**

Same mapping as Task 2:
- `console.debug` → `logger.debug`
- `console.warn` → `logger.warn`
- `console.error` → `logger.error`
- `console.log` → `logger.info`

**Step 3: Verify no console statements remain in these files**

```bash
grep -n "console\." composables/useSchools.ts composables/useCoaches.ts \
  composables/useAuth.ts composables/useInteractions.ts \
  composables/useActiveFamily.ts composables/useSchoolLogos.ts \
  composables/useSavedSearches.ts composables/useViewLogging.ts
```
Expected: No output

**Step 4: Run tests**

```bash
npm test -- tests/unit/composables/useSchools
npm test -- tests/unit/composables/useCoaches
npm test -- tests/unit/composables/useInteractions
npm test -- tests/unit/composables/useAuth
```
Expected: All PASS

**Step 5: Commit**

```bash
git add composables/useSchools.ts composables/useCoaches.ts \
  composables/useAuth.ts composables/useInteractions.ts \
  composables/useActiveFamily.ts composables/useSchoolLogos.ts \
  composables/useSavedSearches.ts composables/useViewLogging.ts
git commit -m "refactor: replace console statements with structured logger in composables"
```

---

### Task 4: Replace remaining console statements in other composables and pages

**Files:** All remaining composables and pages with console statements (use grep to find them)

**Step 1: Find all remaining console statements in composables/ and pages/**

```bash
grep -rn "console\." composables/ pages/ stores/ --include="*.ts" --include="*.vue" \
  | grep -v "node_modules" | grep -v ".spec."
```

**Step 2: For each file found, apply the same pattern**

Add `import { createClientLogger } from "~/utils/logger"` and module-level `const logger = createClientLogger("<name>")`.

Replace all `console.*` with `logger.*`.

**Step 3: Verify**

```bash
grep -rn "console\." composables/ stores/ --include="*.ts"
```
Expected: No output (pages may still have isolated instances in non-critical places)

**Step 4: Run full test suite**

```bash
npm test
```
Expected: All tests PASS

**Step 5: Commit**

```bash
git add -u composables/ stores/ pages/
git commit -m "refactor: complete console statement replacement across codebase"
```

---

## Phase 2: Extract Pages with Direct Supabase Calls

### Task 5: Create `useRecommendationLetters` composable with tests

**Context:** `pages/recommendations/index.vue` calls Supabase directly for load/save/delete of recommendation letters. We extract these into a proper composable.

**Files:**
- Create: `composables/useRecommendationLetters.ts`
- Create: `tests/unit/composables/useRecommendationLetters.spec.ts`

**Step 1: Write the failing tests**

```typescript
// tests/unit/composables/useRecommendationLetters.spec.ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import { setActivePinia, createPinia } from "pinia";
import { useRecommendationLetters } from "~/composables/useRecommendationLetters";

const mockSupabase = { from: vi.fn() };
vi.mock("~/composables/useSupabase", () => ({ useSupabase: () => mockSupabase }));

let mockUserId = "user-123";
vi.mock("~/stores/user", () => ({
  useUserStore: () => ({ get user() { return { id: mockUserId }; } }),
}));

const makeMockQuery = () => {
  const q: any = {
    select: vi.fn().mockReturnThis(),
    insert: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    delete: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    order: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({ data: null, error: null }),
  };
  return q;
};

describe("useRecommendationLetters", () => {
  let mockQuery: any;

  beforeEach(() => {
    vi.clearAllMocks();
    setActivePinia(createPinia());
    mockQuery = makeMockQuery();
    mockSupabase.from.mockReturnValue(mockQuery);
  });

  describe("fetchLetters", () => {
    it("fetches letters for the current user ordered by requested_date desc", async () => {
      mockQuery.order.mockResolvedValue({ data: [], error: null });
      const { fetchLetters, letters } = useRecommendationLetters();
      await fetchLetters();
      expect(mockSupabase.from).toHaveBeenCalledWith("recommendation_letters");
      expect(mockQuery.eq).toHaveBeenCalledWith("user_id", "user-123");
      expect(mockQuery.order).toHaveBeenCalledWith("requested_date", { ascending: false });
      expect(letters.value).toEqual([]);
    });

    it("sets error state on fetch failure", async () => {
      mockQuery.order.mockResolvedValue({ data: null, error: { message: "DB down" } });
      const { fetchLetters, error } = useRecommendationLetters();
      await fetchLetters();
      expect(error.value).toBeTruthy();
    });

    it("sets loading to false after fetch completes", async () => {
      mockQuery.order.mockResolvedValue({ data: [], error: null });
      const { fetchLetters, loading } = useRecommendationLetters();
      await fetchLetters();
      expect(loading.value).toBe(false);
    });
  });

  describe("saveLetter", () => {
    const formData = {
      writer_name: "Dr. Smith",
      writer_email: "smith@uni.edu",
      writer_title: "Professor",
      status: "requested",
      requested_date: "2026-01-01",
      due_date: "",
      received_date: "",
      relationship: "teacher",
      schools_submitted_to: [],
      notes: "",
    };

    it("inserts a new letter when no id provided", async () => {
      mockQuery.select.mockResolvedValue({ data: [{ id: "new-id" }], error: null });
      const { saveLetter } = useRecommendationLetters();
      await saveLetter(formData);
      expect(mockQuery.insert).toHaveBeenCalledWith(
        expect.arrayContaining([expect.objectContaining({ writer_name: "Dr. Smith", user_id: "user-123" })]),
      );
    });

    it("updates an existing letter when id provided", async () => {
      mockQuery.eq.mockResolvedValue({ data: null, error: null });
      const { saveLetter } = useRecommendationLetters();
      await saveLetter(formData, "letter-abc");
      expect(mockQuery.update).toHaveBeenCalledWith(expect.objectContaining({ writer_name: "Dr. Smith" }));
      expect(mockQuery.eq).toHaveBeenCalledWith("id", "letter-abc");
    });

    it("sets error state on save failure", async () => {
      mockQuery.select.mockResolvedValue({ data: null, error: { message: "insert failed" } });
      const { saveLetter, error } = useRecommendationLetters();
      await saveLetter(formData);
      expect(error.value).toBeTruthy();
    });
  });

  describe("deleteLetter", () => {
    it("deletes by id and refreshes the list", async () => {
      mockQuery.eq.mockResolvedValue({ error: null });
      mockQuery.order.mockResolvedValue({ data: [], error: null });
      const { deleteLetter } = useRecommendationLetters();
      await deleteLetter("letter-xyz");
      expect(mockSupabase.from).toHaveBeenCalledWith("recommendation_letters");
      expect(mockQuery.delete).toHaveBeenCalled();
      expect(mockQuery.eq).toHaveBeenCalledWith("id", "letter-xyz");
    });

    it("sets error state on delete failure", async () => {
      mockQuery.eq.mockResolvedValue({ error: { message: "delete failed" } });
      const { deleteLetter, error } = useRecommendationLetters();
      await deleteLetter("letter-xyz");
      expect(error.value).toBeTruthy();
    });
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
npm test -- tests/unit/composables/useRecommendationLetters.spec.ts
```
Expected: FAIL with "Cannot find module '~/composables/useRecommendationLetters'"

**Step 3: Implement the composable**

```typescript
// composables/useRecommendationLetters.ts
import { ref } from "vue";
import { useSupabase } from "~/composables/useSupabase";
import { useUserStore } from "~/stores/user";
import { createClientLogger } from "~/utils/logger";
import type { Database } from "~/types/database";

type RecommendationLetter =
  Database["public"]["Tables"]["recommendation_letters"]["Row"];

type LetterFormData = {
  writer_name: string;
  writer_email: string;
  writer_title: string;
  status: string;
  requested_date: string;
  due_date: string;
  received_date: string;
  relationship: string;
  schools_submitted_to: string[];
  notes: string;
};

const logger = createClientLogger("useRecommendationLetters");

export function useRecommendationLetters() {
  const supabase = useSupabase();
  const userStore = useUserStore();

  const letters = ref<RecommendationLetter[]>([]);
  const loading = ref(false);
  const error = ref<string | null>(null);

  const fetchLetters = async () => {
    if (!userStore.user?.id) return;

    loading.value = true;
    error.value = null;

    try {
      const { data, error: fetchError } = await supabase
        .from("recommendation_letters")
        .select("*")
        .eq("user_id", userStore.user.id)
        .order("requested_date", { ascending: false });

      if (fetchError) throw fetchError;
      letters.value = (data as RecommendationLetter[]) || [];
    } catch (err) {
      const message =
        err instanceof Error ? err.message : "Failed to load letters";
      error.value = message;
      logger.error("fetchLetters failed", err);
    } finally {
      loading.value = false;
    }
  };

  const saveLetter = async (
    formData: LetterFormData,
    existingId?: string | null,
  ) => {
    loading.value = true;
    error.value = null;

    try {
      if (existingId) {
        const { error: updateError } = await supabase
          .from("recommendation_letters")
          .update(formData)
          .eq("id", existingId);
        if (updateError) throw updateError;
      } else {
        const { error: insertError } = await supabase
          .from("recommendation_letters")
          .insert([{ ...formData, user_id: userStore.user?.id }])
          .select();
        if (insertError) throw insertError;
      }

      await fetchLetters();
    } catch (err) {
      const message =
        err instanceof Error ? err.message : "Failed to save letter";
      error.value = message;
      logger.error("saveLetter failed", err);
    } finally {
      loading.value = false;
    }
  };

  const deleteLetter = async (id: string) => {
    error.value = null;

    try {
      const { error: deleteError } = await supabase
        .from("recommendation_letters")
        .delete()
        .eq("id", id);
      if (deleteError) throw deleteError;

      await fetchLetters();
    } catch (err) {
      const message =
        err instanceof Error ? err.message : "Failed to delete letter";
      error.value = message;
      logger.error("deleteLetter failed", err);
    }
  };

  return { letters, loading, error, fetchLetters, saveLetter, deleteLetter };
}
```

**Step 4: Run tests to verify they pass**

```bash
npm test -- tests/unit/composables/useRecommendationLetters.spec.ts
```
Expected: All PASS

**Step 5: Commit**

```bash
git add composables/useRecommendationLetters.ts tests/unit/composables/useRecommendationLetters.spec.ts
git commit -m "feat: extract recommendation letters Supabase calls into useRecommendationLetters composable"
```

---

### Task 6: Update `pages/recommendations/index.vue` to use the composable

**Files:**
- Modify: `pages/recommendations/index.vue`

**Step 1: Replace direct Supabase usage in the script section**

In `pages/recommendations/index.vue`, inside `<script setup>`:

Remove:
```typescript
import { useUserStore } from "~/stores/user";
import type { Database } from "~/types/database";
// ... and the useSupabase() / supabase calls
type RecommendationLetter = Database["public"]["Tables"]["recommendation_letters"]["Row"];
const userStore = useUserStore();
const supabase = useSupabase();
const letters = ref<RecommendationLetter[]>([]);
const loading = ref(false);
```

Add:
```typescript
import { useRecommendationLetters } from "~/composables/useRecommendationLetters";
import type { Database } from "~/types/database";
type RecommendationLetter = Database["public"]["Tables"]["recommendation_letters"]["Row"];

const { letters, loading, error, fetchLetters, saveLetter, deleteLetter } =
  useRecommendationLetters();
```

Remove the `handleSave`, `deleteLetter`, and `loadLetters` function bodies from the page. Replace them with calls to the composable:

```typescript
const handleSave = async () => {
  await saveLetter(formData.value, editingId.value);
  if (!error.value) cancelEdit();
};

const handleDelete = async (id: string) => {
  if (confirm("Delete this recommendation letter record?")) {
    await deleteLetter(id);
  }
};
```

Update `onMounted` to call `fetchLetters()` instead of `loadLetters()`.

Update all template references from `loadLetters()` to `fetchLetters()` and from `deleteLetter(id)` to `handleDelete(id)`.

**Step 2: Verify the page has no more direct `supabase.from("recommendation_letters")` calls**

```bash
grep -n "supabase.from" pages/recommendations/index.vue
```
Expected: No output

**Step 3: Run tests and type check**

```bash
npm run type-check
npm test
```
Expected: All PASS

**Step 4: Commit**

```bash
git add pages/recommendations/index.vue
git commit -m "refactor: use useRecommendationLetters composable in recommendations page"
```

---

### Task 7: Create `useSocialSyncSettings` composable with tests

**Context:** `pages/settings/social-sync.vue` calls Supabase directly for load/save of social sync preferences.

**Files:**
- Create: `composables/useSocialSyncSettings.ts`
- Create: `tests/unit/composables/useSocialSyncSettings.spec.ts`

**Step 1: Write the failing tests**

```typescript
// tests/unit/composables/useSocialSyncSettings.spec.ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import { setActivePinia, createPinia } from "pinia";
import { useSocialSyncSettings } from "~/composables/useSocialSyncSettings";

const mockSupabase = { from: vi.fn() };
vi.mock("~/composables/useSupabase", () => ({ useSupabase: () => mockSupabase }));

let mockUserId = "user-123";
vi.mock("~/stores/user", () => ({
  useUserStore: () => ({ get user() { return { id: mockUserId }; } }),
}));

const makeMockQuery = () => {
  const q: any = {
    select: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({ data: null, error: null }),
  };
  return q;
};

describe("useSocialSyncSettings", () => {
  let mockQuery: any;

  beforeEach(() => {
    vi.clearAllMocks();
    setActivePinia(createPinia());
    mockQuery = makeMockQuery();
    mockSupabase.from.mockReturnValue(mockQuery);
  });

  describe("loadSettings", () => {
    it("fetches social_sync_settings from user_preferences", async () => {
      mockQuery.single.mockResolvedValue({
        data: {
          social_sync_settings: {
            autoSyncEnabled: false,
            notifyOnRecruitingPosts: true,
            notifyOnMentions: false,
            lastSyncTime: null,
          },
        },
        error: null,
      });
      const { loadSettings, autoSyncEnabled, notifyOnRecruitingPosts } =
        useSocialSyncSettings();
      await loadSettings();
      expect(mockSupabase.from).toHaveBeenCalledWith("user_preferences");
      expect(mockQuery.eq).toHaveBeenCalledWith("user_id", "user-123");
      expect(autoSyncEnabled.value).toBe(false);
      expect(notifyOnRecruitingPosts.value).toBe(true);
    });

    it("uses defaults when social_sync_settings is null", async () => {
      mockQuery.single.mockResolvedValue({ data: null, error: null });
      const { loadSettings, autoSyncEnabled } = useSocialSyncSettings();
      await loadSettings();
      expect(autoSyncEnabled.value).toBe(true); // default
    });

    it("does nothing when no user", async () => {
      mockUserId = "";
      const { loadSettings } = useSocialSyncSettings();
      await loadSettings();
      expect(mockSupabase.from).not.toHaveBeenCalled();
      mockUserId = "user-123";
    });
  });

  describe("saveSettings", () => {
    it("updates user_preferences with current settings", async () => {
      mockQuery.eq.mockResolvedValue({ error: null });
      const { saveSettings, autoSyncEnabled } = useSocialSyncSettings();
      autoSyncEnabled.value = false;
      const result = await saveSettings();
      expect(mockQuery.update).toHaveBeenCalledWith(
        expect.objectContaining({
          social_sync_settings: expect.objectContaining({ autoSyncEnabled: false }),
        }),
      );
      expect(result.success).toBe(true);
    });

    it("returns success: false on error", async () => {
      mockQuery.eq.mockResolvedValue({ error: { message: "failed" } });
      const { saveSettings } = useSocialSyncSettings();
      const result = await saveSettings();
      expect(result.success).toBe(false);
    });
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
npm test -- tests/unit/composables/useSocialSyncSettings.spec.ts
```
Expected: FAIL with "Cannot find module '~/composables/useSocialSyncSettings'"

**Step 3: Implement the composable**

```typescript
// composables/useSocialSyncSettings.ts
import { ref } from "vue";
import { useSupabase } from "~/composables/useSupabase";
import { useUserStore } from "~/stores/user";
import { createClientLogger } from "~/utils/logger";

const logger = createClientLogger("useSocialSyncSettings");

export function useSocialSyncSettings() {
  const supabase = useSupabase();
  const userStore = useUserStore();

  const autoSyncEnabled = ref(true);
  const notifyOnRecruitingPosts = ref(false);
  const notifyOnMentions = ref(false);
  const lastSyncTime = ref<string | null>(null);
  const saving = ref(false);

  const loadSettings = async () => {
    if (!userStore.user?.id) return;

    try {
      const { data } = await supabase
        .from("user_preferences")
        .select("social_sync_settings")
        .eq("user_id", userStore.user.id)
        .single();

      const settings = (data as any)?.social_sync_settings;
      if (settings) {
        autoSyncEnabled.value = settings.autoSyncEnabled ?? true;
        notifyOnRecruitingPosts.value = settings.notifyOnRecruitingPosts ?? false;
        notifyOnMentions.value = settings.notifyOnMentions ?? false;
        lastSyncTime.value = settings.lastSyncTime ?? null;
      }
    } catch (err) {
      logger.error("loadSettings failed", err);
    }
  };

  const saveSettings = async (): Promise<{ success: boolean }> => {
    if (!userStore.user?.id) return { success: false };

    saving.value = true;
    try {
      const { error } = await supabase
        .from("user_preferences")
        .update({
          social_sync_settings: {
            autoSyncEnabled: autoSyncEnabled.value,
            notifyOnRecruitingPosts: notifyOnRecruitingPosts.value,
            notifyOnMentions: notifyOnMentions.value,
            lastSyncTime: lastSyncTime.value,
          },
        })
        .eq("user_id", userStore.user.id);

      if (error) throw error;
      return { success: true };
    } catch (err) {
      logger.error("saveSettings failed", err);
      return { success: false };
    } finally {
      saving.value = false;
    }
  };

  return {
    autoSyncEnabled,
    notifyOnRecruitingPosts,
    notifyOnMentions,
    lastSyncTime,
    saving,
    loadSettings,
    saveSettings,
  };
}
```

**Step 4: Run tests to verify they pass**

```bash
npm test -- tests/unit/composables/useSocialSyncSettings.spec.ts
```
Expected: All PASS

**Step 5: Commit**

```bash
git add composables/useSocialSyncSettings.ts tests/unit/composables/useSocialSyncSettings.spec.ts
git commit -m "feat: extract social sync settings Supabase calls into useSocialSyncSettings composable"
```

---

### Task 8: Update `pages/settings/social-sync.vue` to use the composable

**Files:**
- Modify: `pages/settings/social-sync.vue`

**Step 1: Replace direct Supabase usage**

In `pages/settings/social-sync.vue` `<script setup>`:

Remove:
```typescript
// All direct supabase imports and the supabase variable
const supabase = useSupabase();
const autoSyncEnabled = ref(true);
const notifyOnRecruitingPosts = ref(false);
const notifyOnMentions = ref(false);
const lastSyncTime = ref<string | null>(null);
const saving = ref(false);
```

And remove the `loadSettings` and `saveSettings` function bodies.

Add:
```typescript
import { useSocialSyncSettings } from "~/composables/useSocialSyncSettings";

const {
  autoSyncEnabled,
  notifyOnRecruitingPosts,
  notifyOnMentions,
  lastSyncTime,
  saving,
  loadSettings,
  saveSettings,
} = useSocialSyncSettings();
```

Update `saveSettings` call in the page to handle the returned `{ success }`:

```typescript
const handleSave = async () => {
  const result = await saveSettings();
  if (result.success) {
    syncMessage.value = "Settings saved!";
    syncSuccess.value = true;
    setTimeout(() => { syncMessage.value = ""; }, 3000);
  } else {
    syncMessage.value = "Failed to save settings";
    syncSuccess.value = false;
  }
};
```

Update `onMounted` to call `loadSettings()`.

**Step 2: Verify no direct Supabase calls remain for `user_preferences`**

```bash
grep -n "supabase.from(\"user_preferences\")" pages/settings/social-sync.vue
```
Expected: No output

**Step 3: Type check and test**

```bash
npm run type-check
npm test
```
Expected: All PASS

**Step 4: Commit**

```bash
git add pages/settings/social-sync.vue
git commit -m "refactor: use useSocialSyncSettings composable in social-sync page"
```

---

## Phase 3: Request Deduplication

### Task 9: Add in-flight deduplication to `useSchools`

**Context:** If `fetchSchools()` is called multiple times simultaneously (e.g., two components mount at the same time), it currently fires N duplicate Supabase queries. We prevent this with a simple in-flight promise cache.

**Files:**
- Modify: `composables/useSchools.ts`
- Modify: `tests/unit/composables/useSchools.spec.ts` (add new test)

**Step 1: Write the failing test**

Add this test to `tests/unit/composables/useSchools.spec.ts` in the `describe("fetchSchools")` block:

```typescript
it("deduplicates concurrent fetchSchools calls - only one Supabase query fires", async () => {
  // Slow Supabase response to ensure overlap
  let resolveQuery!: (val: any) => void;
  const queryPromise = new Promise((resolve) => { resolveQuery = resolve; });
  mockQuery.order.mockReturnValue(queryPromise);

  const { fetchSchools } = useSchools();

  // Fire two concurrent calls
  const p1 = fetchSchools();
  const p2 = fetchSchools();

  // Resolve the underlying query
  resolveQuery({ data: [], error: null });
  await Promise.all([p1, p2]);

  // Supabase should only have been called once
  expect(mockSupabase.from).toHaveBeenCalledTimes(1);
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- tests/unit/composables/useSchools.spec.ts -t "deduplicates"
```
Expected: FAIL (mockSupabase.from called twice)

**Step 3: Add deduplication to useSchools**

In `composables/useSchools.ts`, find the module-level state (the refs inside the closure) and add:

```typescript
// In-flight deduplication: prevents concurrent duplicate Supabase calls
let fetchInFlight: Promise<void> | null = null;
```

Then wrap the `fetchSchools` function body:

```typescript
const fetchSchools = async (): Promise<void> => {
  if (fetchInFlight) return fetchInFlight;

  fetchInFlight = (async () => {
    // ... existing implementation unchanged ...
  })().finally(() => {
    fetchInFlight = null;
  });

  return fetchInFlight;
};
```

**Step 4: Run tests to verify they pass**

```bash
npm test -- tests/unit/composables/useSchools.spec.ts
```
Expected: All PASS including new deduplication test

**Step 5: Commit**

```bash
git add composables/useSchools.ts tests/unit/composables/useSchools.spec.ts
git commit -m "perf: add in-flight request deduplication to useSchools"
```

---

### Task 10: Add in-flight deduplication to `useCoaches`

**Files:**
- Modify: `composables/useCoaches.ts`
- Modify: `tests/unit/composables/useCoaches.spec.ts` (add new test)

**Step 1: Write the failing test**

Add to `tests/unit/composables/useCoaches.spec.ts`:

```typescript
it("deduplicates concurrent fetchCoaches calls for the same schoolId", async () => {
  let resolveQuery!: (val: any) => void;
  const queryPromise = new Promise((resolve) => { resolveQuery = resolve; });
  mockQuery.order.mockReturnValue(queryPromise);

  const { fetchCoaches } = useCoaches();

  const p1 = fetchCoaches("school-1");
  const p2 = fetchCoaches("school-1");

  resolveQuery({ data: [], error: null });
  await Promise.all([p1, p2]);

  expect(mockSupabase.from).toHaveBeenCalledTimes(1);
});
```

**Step 2: Run test to verify it fails**

```bash
npm test -- tests/unit/composables/useCoaches.spec.ts -t "deduplicates"
```
Expected: FAIL

**Step 3: Add deduplication to useCoaches**

In `composables/useCoaches.ts`, add a per-schoolId in-flight map:

```typescript
// Keyed by schoolId to allow concurrent fetches for different schools
const fetchInFlight = new Map<string, Promise<void>>();
```

Then update `fetchCoaches`:

```typescript
const fetchCoaches = async (schoolId: string): Promise<void> => {
  if (fetchInFlight.has(schoolId)) return fetchInFlight.get(schoolId)!;

  const promise = (async () => {
    // ... existing implementation unchanged ...
  })().finally(() => {
    fetchInFlight.delete(schoolId);
  });

  fetchInFlight.set(schoolId, promise);
  return promise;
};
```

**Step 4: Run tests to verify they pass**

```bash
npm test -- tests/unit/composables/useCoaches.spec.ts
```
Expected: All PASS

**Step 5: Commit**

```bash
git add composables/useCoaches.ts tests/unit/composables/useCoaches.spec.ts
git commit -m "perf: add in-flight request deduplication to useCoaches"
```

---

## Final Verification

### Task 11: Full test suite and type check

**Step 1: Run full test suite**

```bash
npm test
```
Expected: All tests PASS (≥5653, probably more due to new tests)

**Step 2: Type check**

```bash
npm run type-check
```
Expected: No errors

**Step 3: Lint**

```bash
npm run lint:fix
```
Expected: No errors

**Step 4: Verify no remaining direct console statements in composables/stores**

```bash
grep -rn "console\." composables/ stores/ --include="*.ts" | grep -v ".spec."
```
Expected: No output (or only in utils/logger.ts itself)

**Step 5: Final commit if anything was auto-fixed**

```bash
git add -u
git commit -m "chore: lint and type check fixes"
```

---

## Summary of Changes

| Task | Files Changed | Purpose |
|------|--------------|---------|
| 1 | `utils/logger.ts`, test | Client-side logger utility |
| 2 | `stores/user.ts` | Replace 18 console statements |
| 3 | 8 composable files | Replace ~200 console statements |
| 4 | Remaining files | Complete console replacement |
| 5 | `composables/useRecommendationLetters.ts`, test | Extract DB logic from page |
| 6 | `pages/recommendations/index.vue` | Use new composable |
| 7 | `composables/useSocialSyncSettings.ts`, test | Extract DB logic from page |
| 8 | `pages/settings/social-sync.vue` | Use new composable |
| 9 | `composables/useSchools.ts`, test | Request deduplication |
| 10 | `composables/useCoaches.ts`, test | Request deduplication |
| 11 | — | Full verification |

## Unresolved Questions

None — all requirements are concrete with known file paths, line numbers, and implementations.
